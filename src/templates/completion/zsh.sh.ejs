#compdef lt

# lt completion for Zsh shell
# Auto-generated by lt CLI - supports arbitrary nesting depth

<%
// Helper to generate safe variable name from path
function varName(path) {
  return path.replace(/-/g, '_') + '_cmds';
}

// Recursively collect all nodes that have children (need completion arrays)
function collectNodesWithChildren(nodes, result = []) {
  for (const node of nodes) {
    if (node.children.length > 0) {
      result.push(node);
      collectNodesWithChildren(node.children, result);
    }
  }
  return result;
}

// Generate completion entries for a node's children
function generateEntries(children) {
  return children.map(c => `'${c.name}:${c.description.replace(/'/g, "''")}'`).join('\n        ');
}

const nodesWithChildren = collectNodesWithChildren(props.commandTree);
-%>
_lt() {
    local curcontext="$curcontext" state state_descr line
    typeset -A opt_args

    # Root level commands
    local -a root_cmds
    root_cmds=(
        <%- generateEntries(props.commandTree) %>
    )

<% for (const node of nodesWithChildren) { -%>
    # <%- node.path %> subcommands
    local -a <%- varName(node.path) %>
    <%- varName(node.path) %>=(
        <%- generateEntries(node.children) %>
    )

<% } -%>
    # Build arguments spec dynamically based on max depth
    _arguments -C \
        '1: :->cmd1' \
<% for (let i = 2; i <= props.maxDepth; i++) { -%>
        '<%- i %>: :->cmd<%- i %>' \
<% } -%>
        '*::arg:->args'

    case "$state" in
        cmd1)
            _describe -t commands 'lt commands' root_cmds
            ;;
<% for (let depth = 2; depth <= props.maxDepth; depth++) { -%>
        cmd<%- depth %>)
            # Determine parent path from words[2..<%- depth %>]
<%
  // Generate nested case statements for this depth
  function generateCasesForDepth(nodes, currentDepth, targetDepth, wordIndices) {
    let output = '';
    const indent = '            ' + '    '.repeat(currentDepth - 2);

    if (currentDepth === targetDepth) {
      // We're at the target depth, list completions
      for (const node of nodes) {
        if (node.children.length > 0) {
          output += `${indent}${node.name})\n`;
          output += `${indent}    _describe -t commands '${node.name} commands' ${varName(node.path)}\n`;
          output += `${indent}    ;;\n`;
        }
      }
    } else {
      // Need to go deeper
      for (const node of nodes) {
        if (node.children.length > 0) {
          const hasGrandchildren = node.children.some(c => c.children.length > 0);
          if (hasGrandchildren || currentDepth + 1 === targetDepth) {
            output += `${indent}${node.name})\n`;
            if (currentDepth + 1 === targetDepth) {
              // Next level is target
              output += `${indent}    case "$words[${currentDepth + 1}]" in\n`;
              output += generateCasesForDepth(node.children, currentDepth + 1, targetDepth, wordIndices);
              output += `${indent}    esac\n`;
            } else {
              output += `${indent}    case "$words[${currentDepth + 1}]" in\n`;
              output += generateCasesForDepth(node.children, currentDepth + 1, targetDepth, wordIndices);
              output += `${indent}    esac\n`;
            }
            output += `${indent}    ;;\n`;
          }
        }
      }
    }
    return output;
  }
-%>
            case "$words[2]" in
<%- generateCasesForDepth(props.commandTree, 2, depth, []) -%>
            esac
            ;;
<% } -%>
        args)
            _arguments \
                '--help[Show help]' \
                '--version[Show version]' \
                '--noConfirm[Skip confirmations]' \
                '--dry-run[Show what would be done]'
            ;;
    esac
}

# Register completion function
(( $+functions[compdef] )) && compdef _lt lt || true
